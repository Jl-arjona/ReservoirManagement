 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/main.py b/main.py
index 2f76740a79747491d7c99b17b517886a23fb7fe6..9551847673cc7194e4849157392a34da8553f4c0 100644
--- a/main.py
+++ b/main.py
@@ -1,56 +1,47 @@
 """
 Extended reservoir-management QUBO model (based on Sustainability 13, 3470).
 
 - Discretized y_ij in [0, 1] using K bits (QUBO).
 - Constraints implemented as quadratic penalties via
   dimod.BinaryQuadraticModel.add_linear_inequality_constraint.
-- Solvable with:
-    - neal.SimulatedAnnealingSampler (classical)
-    - D-Wave LeapHybridSampler (if available and token configured)
+- Solvable with the classical dwave.samplers SimulatedAnnealingSampler.
 
 Main entry point: run_example_from_article()
 """
 
 from __future__ import annotations
 
 from dataclasses import dataclass
 from typing import List, Dict, Tuple
 
 import numpy as np
 import dimod
 
 from dwave.samplers import SimulatedAnnealingSampler
 
 
-try:
-    from dwave.system import LeapHybridSampler
-    HAVE_DWAVE = True
-except ImportError:
-    HAVE_DWAVE = False
-
-
 # ---------------------------------------------------------------------------
 # Data containers
 # ---------------------------------------------------------------------------
 
 @dataclass
 class ReservoirInstance:
     """Problem data for the reservoir-management model."""
     num_pumps: int
     time: List[int]           # list of time slots (e.g. [1..24])
     power: List[float]        # power[p] (kW)
     costs: List[float]        # costs[t] (tariff)
     flow: List[float]         # flow[p] (m^3/h)
     demand: List[float]       # demand[t] (m^3)
     v_init: float             # initial volume
     v_min: float              # minimum reservoir level
     v_max: float              # maximum reservoir level
     min_time_per_pump: float  # minimum total operating time per pump (h)
     max_pumps_per_slot: int   # max simultaneous pumps per time slot
 
 
 @dataclass
 class PenaltyConfig:
     """Penalty weights for the QUBO formulation."""
     K: int = 5            # bits for y_ij
     gamma: float = 10.0   # objective scale (cost terms)
@@ -445,69 +436,60 @@ def example_instance_from_article() -> ReservoirInstance:
     v_init = 550.0
     v_min = 523.5
     v_max = 1500.0
 
     # from the article: each pump must work at least 1 hour per day
     min_time_per_pump = 1.0
     # at most 6 pumps simultaneously
     max_pumps_per_slot = 6
 
     return ReservoirInstance(
         num_pumps=num_pumps,
         time=time,
         power=power,
         costs=costs,
         flow=flow,
         demand=demand,
         v_init=v_init,
         v_min=v_min,
         v_max=v_max,
         min_time_per_pump=min_time_per_pump,
         max_pumps_per_slot=max_pumps_per_slot
     )
 
 
 def run_example_from_article(
-    use_dwave: bool = False,
     num_reads: int = 100
 ) -> None:
     """
     Build and solve the example instance using QUBO.
 
     Arguments:
-        use_dwave: if True and LeapHybridSampler is available, use it.
-                   otherwise, use neal.SimulatedAnnealingSampler.
-        num_reads: number of reads (for SA); ignored by hybrid sampler.
+        num_reads: number of reads for the simulated annealer.
     """
     inst = example_instance_from_article()
     pen = PenaltyConfig(
         K=5,
         gamma=10.0,
         lam_min_time=50.0,
         lam_max_pumps=50.0,
         lam_reservoir=50.0,
         lam_couple=10.0
     )
 
     bqm, x, y_bits = build_extended_bqm(inst, pen)
 
     # Choose sampler
-    if use_dwave and HAVE_DWAVE:
-        print("\nUsing LeapHybridSampler...")
-        sampler = LeapHybridSampler()
-        sampleset = sampler.sample(bqm)
-    else:
-        print("\nUsing SimulatedAnnealingSampler (neal)...")
-        sampler = SimulatedAnnealingSampler()
-        sampleset = sampler.sample(bqm, num_reads=num_reads)
+    print("\nUsing SimulatedAnnealingSampler from dwave.samplers...")
+    sampler = SimulatedAnnealingSampler()
+    sampleset = sampler.sample(bqm, num_reads=num_reads)
 
     best = sampleset.first
     sample = best.sample
     print("\nBest energy:", best.energy)
 
     summarize_solution(inst, sample, x, y_bits, pen)
     check_constraints(inst, sample, x, y_bits, pen, tol=1e-3)
 
 
 if __name__ == "__main__":
-    # Change use_dwave=True if you want to use LeapHybrid and have a token.
-    run_example_from_article(use_dwave=False, num_reads=50)
+    run_example_from_article(num_reads=50)
 
EOF
)